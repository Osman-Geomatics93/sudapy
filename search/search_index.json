{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"SudaPy","text":"<p>Sudan-focused Python toolkit for Geomatics -- GIS, remote sensing, and surveying workflows.</p> <ul> <li> <p> CRS Presets for Sudan</p> <p>Built-in coordinate reference systems for UTM zones 34--37N (WGS 84 and Adindan) with automatic zone detection.</p> <p> CRS Guide</p> </li> <li> <p> Vector Operations</p> <p>Reproject, clip, dissolve, buffer, simplify, calculate area, and fix invalid geometries.</p> <p> Vector Guide</p> </li> <li> <p> Raster Operations</p> <p>Clip, reproject, resample, mosaic, hillshade, and slope analysis for raster data.</p> <p> Raster Guide</p> </li> <li> <p> CLI &amp; Python API</p> <p>Use SudaPy from the command line or import it as a Python library in your scripts.</p> <p> CLI Reference</p> </li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"CLIPython <pre><code># Find the right CRS for Khartoum\nsudapy crs suggest --lon 32.5 --lat 15.6\n\n# Reproject a vector file\nsudapy vector reproject --in regions.gpkg --out regions_utm.gpkg --to 32636\n\n# Generate a quick map\nsudapy map quick --in regions.gpkg --out map.html\n</code></pre> <pre><code>from sudapy.crs.registry import suggest_utm_zone\nfrom sudapy.vector.ops import reproject, calculate_area\n\n# Suggest CRS for a point in Sudan\nsuggestions = suggest_utm_zone(lon=32.5, lat=15.6)\nprint(suggestions)\n# [{'epsg': 32636, 'zone': 36, 'name': 'WGS 84 / UTM zone 36N', ...}]\n\n# Reproject and calculate area\ngdf = reproject(\"parcels.gpkg\", to_epsg=32636, out=\"parcels_utm.gpkg\")\ngdf = calculate_area(gdf, field=\"area_m2\", out=\"parcels_area.gpkg\")\n</code></pre>"},{"location":"#install","title":"Install","text":"<pre><code>pip install sudapy\n</code></pre> <p>For geospatial dependencies on Windows, use conda first:</p> <pre><code>conda install -c conda-forge geopandas rasterio fiona pyproj\npip install sudapy\n</code></pre> <p> Full installation guide</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to SudaPy will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#101-2026-02-01","title":"[1.0.1] - 2026-02-01","text":""},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Project URLs now point to correct GitHub repository (Osman-Geomatics93/sudapy).</li> <li>INSTALL_OFFLINE.md link uses absolute GitHub URL (no longer 404s on PyPI).</li> <li>Version/classifier alignment: 1.x with Production/Stable status.</li> </ul>"},{"location":"changelog/#100-2026-02-01","title":"[1.0.0] - 2026-02-01","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Initial release of SudaPy.</li> <li>Built-in CRS presets for Sudan: WGS 84 UTM zones 34-37N, Adindan UTM zones 35-37N.</li> <li>CRS suggestion engine (<code>sudapy crs suggest</code>) for automatic UTM zone detection.</li> <li>Vector operations: reproject, clip, dissolve, area calculation, buffer, simplify, fix-geometry.</li> <li>Raster operations: clip by vector, reproject, resample, mosaic, hillshade, slope.</li> <li>Quick map visualization export to PNG and interactive HTML.</li> <li><code>sudapy doctor</code> command for environment diagnostics.</li> <li><code>sudapy init</code> command for project scaffolding.</li> <li><code>sudapy report</code> command for dataset summary.</li> <li><code>sudapy batch</code> command for batch processing.</li> <li>Remote sensing Sentinel search/download (optional <code>[rs]</code> extra).</li> <li>Offline installation support with wheelhouse builder script.</li> <li>conda <code>environment.yml</code> for known-good geospatial setup.</li> <li>GitHub Actions CI for Linux and Windows.</li> <li>Full test suite for CRS logic, vector operations, and area calculations.</li> </ul>"},{"location":"cli/","title":"CLI Reference","text":"<p>SudaPy provides a command-line interface built with Typer. All commands use <code>--in</code> / <code>--out</code> for input/output files.</p> <pre><code>sudapy --help\n</code></pre>"},{"location":"cli/#global-commands","title":"Global commands","text":""},{"location":"cli/#sudapy-info","title":"<code>sudapy info</code>","text":"<p>Show SudaPy version, Python version, platform, and dependency status.</p> <pre><code>sudapy info\n</code></pre>"},{"location":"cli/#sudapy-doctor","title":"<code>sudapy doctor</code>","text":"<p>Run environment diagnostics: checks Python version, core imports, GDAL, PROJ data, and GeoPackage read/write.</p> <pre><code>sudapy doctor\n</code></pre>"},{"location":"cli/#sudapy-init","title":"<code>sudapy init</code>","text":"<p>Scaffold a new geomatics project with standard folder structure.</p> <pre><code>sudapy init PROJECT_NAME\n</code></pre> <p>Creates: <code>data_raw/</code>, <code>data_clean/</code>, <code>outputs/</code>, <code>maps/</code>, <code>scripts/process.py</code>, and <code>README.md</code>.</p>"},{"location":"cli/#sudapy-report","title":"<code>sudapy report</code>","text":"<p>Print a summary report for a vector dataset.</p> <pre><code>sudapy report --in data/parcels.gpkg\n</code></pre> <p>Reports: feature count, columns, geometry types, CRS, bounds, null/invalid geometry count.</p>"},{"location":"cli/#sudapy-batch","title":"<code>sudapy batch</code>","text":"<p>Run an operation on all vector files in a directory.</p> <pre><code>sudapy batch OPERATION --in INPUT_DIR --out OUTPUT_DIR [OPTIONS]\n</code></pre> <p>Operations: <code>reproject</code>, <code>clip</code>, <code>buffer</code>, <code>area</code>, <code>simplify</code>, <code>fix-geometry</code>.</p> <p>See Batch Processing Guide for details.</p>"},{"location":"cli/#crs-commands","title":"CRS commands","text":""},{"location":"cli/#sudapy-crs-list","title":"<code>sudapy crs list</code>","text":"<p>Show all built-in Sudan CRS presets.</p> <pre><code>sudapy crs list\n</code></pre>"},{"location":"cli/#sudapy-crs-suggest","title":"<code>sudapy crs suggest</code>","text":"<p>Suggest the appropriate UTM zone for a coordinate.</p> <pre><code>sudapy crs suggest --lon 32.5 --lat 15.6\n</code></pre> Option Required Description <code>--lon</code> Yes Longitude in decimal degrees <code>--lat</code> Yes Latitude in decimal degrees"},{"location":"cli/#vector-commands","title":"Vector commands","text":""},{"location":"cli/#sudapy-vector-reproject","title":"<code>sudapy vector reproject</code>","text":"<pre><code>sudapy vector reproject --in INPUT --out OUTPUT --to EPSG\n</code></pre> Option Required Description <code>--in</code> Yes Input vector file <code>--out</code> Yes Output vector file <code>--to</code> Yes Target EPSG code"},{"location":"cli/#sudapy-vector-clip","title":"<code>sudapy vector clip</code>","text":"<pre><code>sudapy vector clip --in INPUT --clip MASK --out OUTPUT\n</code></pre> Option Required Description <code>--in</code> Yes Input vector file <code>--clip</code> Yes Clipping geometry file <code>--out</code> Yes Output vector file"},{"location":"cli/#sudapy-vector-dissolve","title":"<code>sudapy vector dissolve</code>","text":"<pre><code>sudapy vector dissolve --in INPUT --by FIELD --out OUTPUT\n</code></pre> Option Required Description <code>--in</code> Yes Input vector file <code>--by</code> Yes Field name to dissolve on <code>--out</code> Yes Output vector file"},{"location":"cli/#sudapy-vector-area","title":"<code>sudapy vector area</code>","text":"<pre><code>sudapy vector area --in INPUT --out OUTPUT [--field FIELD]\n</code></pre> Option Required Default Description <code>--in</code> Yes Input vector file <code>--out</code> Yes Output vector file <code>--field</code> No <code>area_m2</code> Name for the area column"},{"location":"cli/#sudapy-vector-buffer","title":"<code>sudapy vector buffer</code>","text":"<pre><code>sudapy vector buffer --in INPUT --distance METERS --out OUTPUT\n</code></pre> Option Required Description <code>--in</code> Yes Input vector file <code>--distance</code> Yes Buffer distance in meters <code>--out</code> Yes Output vector file"},{"location":"cli/#sudapy-vector-simplify","title":"<code>sudapy vector simplify</code>","text":"<pre><code>sudapy vector simplify --in INPUT --tolerance METERS --out OUTPUT\n</code></pre> Option Required Description <code>--in</code> Yes Input vector file <code>--tolerance</code> Yes Simplification tolerance in meters <code>--out</code> Yes Output vector file"},{"location":"cli/#sudapy-vector-fix-geometry","title":"<code>sudapy vector fix-geometry</code>","text":"<pre><code>sudapy vector fix-geometry --in INPUT --out OUTPUT\n</code></pre> Option Required Description <code>--in</code> Yes Input vector file <code>--out</code> Yes Output vector file"},{"location":"cli/#raster-commands","title":"Raster commands","text":""},{"location":"cli/#sudapy-raster-clip","title":"<code>sudapy raster clip</code>","text":"<pre><code>sudapy raster clip --in INPUT --clip VECTOR --out OUTPUT\n</code></pre> Option Required Description <code>--in</code> Yes Input raster file <code>--clip</code> Yes Clipping vector file <code>--out</code> Yes Output raster file"},{"location":"cli/#sudapy-raster-reproject","title":"<code>sudapy raster reproject</code>","text":"<pre><code>sudapy raster reproject --in INPUT --out OUTPUT --to EPSG\n</code></pre> Option Required Description <code>--in</code> Yes Input raster file <code>--out</code> Yes Output raster file <code>--to</code> Yes Target EPSG code"},{"location":"cli/#sudapy-raster-resample","title":"<code>sudapy raster resample</code>","text":"<pre><code>sudapy raster resample --in INPUT --out OUTPUT --scale FACTOR [--method METHOD]\n</code></pre> Option Required Default Description <code>--in</code> Yes Input raster file <code>--out</code> Yes Output raster file <code>--scale</code> Yes Scale factor (2.0 = double resolution) <code>--method</code> No <code>bilinear</code> Resampling: <code>nearest</code>, <code>bilinear</code>, <code>cubic</code>"},{"location":"cli/#sudapy-raster-mosaic","title":"<code>sudapy raster mosaic</code>","text":"<pre><code>sudapy raster mosaic --in TILE_DIR --out OUTPUT\n</code></pre> Option Required Description <code>--in</code> Yes Directory with raster tiles <code>--out</code> Yes Output merged raster"},{"location":"cli/#sudapy-raster-hillshade","title":"<code>sudapy raster hillshade</code>","text":"<pre><code>sudapy raster hillshade --in DEM --out OUTPUT [--azimuth DEG] [--altitude DEG]\n</code></pre> Option Required Default Description <code>--in</code> Yes Input DEM raster <code>--out</code> Yes Output hillshade raster <code>--azimuth</code> No <code>315.0</code> Sun azimuth in degrees <code>--altitude</code> No <code>45.0</code> Sun altitude in degrees"},{"location":"cli/#sudapy-raster-slope","title":"<code>sudapy raster slope</code>","text":"<pre><code>sudapy raster slope --in DEM --out OUTPUT\n</code></pre> Option Required Description <code>--in</code> Yes Input DEM raster <code>--out</code> Yes Output slope raster (degrees)"},{"location":"cli/#map-commands","title":"Map commands","text":""},{"location":"cli/#sudapy-map-quick","title":"<code>sudapy map quick</code>","text":"<pre><code>sudapy map quick --in INPUT --out OUTPUT\n</code></pre> Option Required Description <code>--in</code> Yes Input vector or raster file <code>--out</code> Yes Output <code>.png</code> (static) or <code>.html</code> (interactive)"},{"location":"cli/#remote-sensing-commands","title":"Remote sensing commands","text":"<p>Note</p> <p>Requires <code>pip install \"sudapy[rs]\"</code> and Copernicus credentials.</p>"},{"location":"cli/#sudapy-rs-sentinel-search","title":"<code>sudapy rs sentinel-search</code>","text":"<pre><code>sudapy rs sentinel-search --lon LON --lat LAT --start DATE --end DATE [--platform NAME] [--max-cloud PCT]\n</code></pre> Option Required Default Description <code>--lon</code> Yes Center longitude <code>--lat</code> Yes Center latitude <code>--start</code> Yes Start date (YYYY-MM-DD) <code>--end</code> Yes End date (YYYY-MM-DD) <code>--platform</code> No <code>Sentinel-2</code> Satellite platform <code>--max-cloud</code> No <code>30</code> Max cloud cover %"},{"location":"cli/#sudapy-rs-sentinel-download","title":"<code>sudapy rs sentinel-download</code>","text":"<pre><code>sudapy rs sentinel-download --uuid UUID [--out DIR]\n</code></pre> Option Required Default Description <code>--uuid</code> Yes Scene UUID from search <code>--out</code> No <code>.</code> Output directory"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions to SudaPy are welcome. This page covers the development setup and workflow.</p>"},{"location":"contributing/#development-setup","title":"Development setup","text":"<pre><code>git clone https://github.com/Osman-Geomatics93/sudapy.git\ncd sudapy\npip install -e \".[dev,all]\"\n</code></pre>"},{"location":"contributing/#running-tests","title":"Running tests","text":"<pre><code>pytest\n</code></pre> <p>Tests are in the <code>tests/</code> directory and cover CRS logic, vector operations, and area calculations.</p>"},{"location":"contributing/#code-style","title":"Code style","text":"<p>SudaPy uses Ruff for linting and formatting:</p> <pre><code>ruff check src/ tests/\nruff format src/ tests/\n</code></pre> <p>Configuration is in <code>pyproject.toml</code>:</p> <ul> <li>Target: Python 3.9</li> <li>Line length: 100</li> <li>Rules: E, F, W, I, UP, B, SIM</li> </ul>"},{"location":"contributing/#type-checking","title":"Type checking","text":"<pre><code>mypy src/sudapy/\n</code></pre>"},{"location":"contributing/#project-structure","title":"Project structure","text":"<pre><code>src/sudapy/\n    __init__.py          # Package version\n    core/\n        errors.py        # Custom exceptions with hints\n        logging.py       # Rich-based logging\n    cli/\n        main.py          # Typer CLI application\n    crs/\n        registry.py      # Sudan CRS presets and UTM suggestion\n    vector/\n        ops.py           # Vector geoprocessing\n    raster/\n        ops.py           # Raster geoprocessing\n    viz/\n        maps.py          # Quick map visualization\n    rs/\n        sentinel.py      # Sentinel satellite search &amp; download\ntests/\n    test_crs.py          # CRS preset and suggestion tests\n    test_vector.py       # Vector operation tests\n</code></pre>"},{"location":"contributing/#adding-a-new-crs-preset","title":"Adding a new CRS preset","text":"<p>Edit <code>src/sudapy/crs/registry.py</code> and add a new <code>CRSPreset</code> to <code>SUDAN_CRS_PRESETS</code>:</p> <pre><code>CRSPreset(\n    epsg=XXXXX,\n    name=\"Name / UTM zone XXN\",\n    description=\"Description of coverage area\",\n    region=\"Region name\",\n),\n</code></pre> <p>If the zone needs Adindan suggestions, add it to the <code>adindan_map</code> dict in <code>suggest_utm_zone()</code>.</p>"},{"location":"contributing/#adding-a-new-vector-operation","title":"Adding a new vector operation","text":"<ol> <li>Add the function to <code>src/sudapy/vector/ops.py</code></li> <li>Add a CLI command in <code>src/sudapy/cli/main.py</code> under <code>vector_app</code></li> <li>Add the operation to the <code>batch</code> command's dispatch</li> <li>Add tests in <code>tests/test_vector.py</code></li> <li>Document in <code>docs/guide/vector.md</code></li> </ol>"},{"location":"contributing/#submitting-changes","title":"Submitting changes","text":"<ol> <li>Fork the repository</li> <li>Create a feature branch: <code>git checkout -b feature/my-feature</code></li> <li>Make your changes and add tests</li> <li>Run <code>pytest</code> and <code>ruff check src/ tests/</code></li> <li>Commit and push</li> <li>Open a pull request against <code>main</code></li> </ol>"},{"location":"contributing/#ci","title":"CI","text":"<p>GitHub Actions runs on every push and PR:</p> <ul> <li>Lint with Ruff</li> <li>Test matrix: Ubuntu + Windows, Python 3.9 / 3.11 / 3.12</li> </ul>"},{"location":"api/crs/","title":"sudapy.crs.registry","text":"<p>CRS presets and UTM zone suggestion for Sudan.</p>"},{"location":"api/crs/#sudapy.crs.registry","title":"sudapy.crs.registry","text":"<p>Built-in CRS registry for Sudan and surrounding regions.</p> <p>Contains common coordinate reference systems used in Sudanese geomatics, plus a helper to suggest the appropriate UTM zone for a given coordinate.</p>"},{"location":"api/crs/#sudapy.crs.registry.CRSPreset","title":"CRSPreset  <code>dataclass</code>","text":"<p>A named CRS preset.</p> Source code in <code>src\\sudapy\\crs\\registry.py</code> <pre><code>@dataclass(frozen=True)\nclass CRSPreset:\n    \"\"\"A named CRS preset.\"\"\"\n\n    epsg: int\n    name: str\n    description: str\n    region: str\n</code></pre>"},{"location":"api/crs/#sudapy.crs.registry.list_presets","title":"list_presets","text":"<pre><code>list_presets() -&gt; list[CRSPreset]\n</code></pre> <p>Return all built-in Sudan CRS presets.</p> Source code in <code>src\\sudapy\\crs\\registry.py</code> <pre><code>def list_presets() -&gt; list[CRSPreset]:\n    \"\"\"Return all built-in Sudan CRS presets.\"\"\"\n    return list(SUDAN_CRS_PRESETS)\n</code></pre>"},{"location":"api/crs/#sudapy.crs.registry.get_preset","title":"get_preset","text":"<pre><code>get_preset(epsg: int) -&gt; CRSPreset | None\n</code></pre> <p>Lookup a preset by EPSG code. Returns <code>None</code> if not found.</p> Source code in <code>src\\sudapy\\crs\\registry.py</code> <pre><code>def get_preset(epsg: int) -&gt; CRSPreset | None:\n    \"\"\"Lookup a preset by EPSG code. Returns ``None`` if not found.\"\"\"\n    for p in SUDAN_CRS_PRESETS:\n        if p.epsg == epsg:\n            return p\n    return None\n</code></pre>"},{"location":"api/crs/#sudapy.crs.registry.suggest_utm_zone","title":"suggest_utm_zone","text":"<pre><code>suggest_utm_zone(lon: float, lat: float) -&gt; list[dict]\n</code></pre> <p>Suggest appropriate UTM EPSG codes for a given longitude/latitude.</p> <p>Parameters:</p> Name Type Description Default <code>lon</code> <code>float</code> <p>Longitude in decimal degrees.</p> required <code>lat</code> <code>float</code> <p>Latitude in decimal degrees.</p> required <p>Returns:</p> Type Description <code>list[dict]</code> <p>A list of dicts with keys <code>epsg</code>, <code>zone</code>, <code>hemisphere</code>, <code>name</code>.</p> Source code in <code>src\\sudapy\\crs\\registry.py</code> <pre><code>def suggest_utm_zone(lon: float, lat: float) -&gt; list[dict]:\n    \"\"\"Suggest appropriate UTM EPSG codes for a given longitude/latitude.\n\n    Args:\n        lon: Longitude in decimal degrees.\n        lat: Latitude in decimal degrees.\n\n    Returns:\n        A list of dicts with keys ``epsg``, ``zone``, ``hemisphere``, ``name``.\n    \"\"\"\n    if not (-180 &lt;= lon &lt;= 180):\n        raise ValueError(f\"Longitude {lon} out of range [-180, 180]\")\n    if not (-90 &lt;= lat &lt;= 90):\n        raise ValueError(f\"Latitude {lat} out of range [-90, 90]\")\n\n    zone_number = int(math.floor((lon + 180) / 6)) + 1\n    hemisphere = \"N\" if lat &gt;= 0 else \"S\"\n\n    base_epsg = 32600 if hemisphere == \"N\" else 32700\n    wgs84_epsg = base_epsg + zone_number\n\n    suggestions: list[dict] = [\n        {\n            \"epsg\": wgs84_epsg,\n            \"zone\": zone_number,\n            \"hemisphere\": hemisphere,\n            \"name\": f\"WGS 84 / UTM zone {zone_number}{hemisphere}\",\n            \"datum\": \"WGS 84\",\n        },\n    ]\n\n    # If the point falls in a zone covered by Adindan presets, suggest those too.\n    adindan_map = {35: 20135, 36: 20136, 37: 20137}\n    if zone_number in adindan_map and hemisphere == \"N\":\n        suggestions.append(\n            {\n                \"epsg\": adindan_map[zone_number],\n                \"zone\": zone_number,\n                \"hemisphere\": hemisphere,\n                \"name\": f\"Adindan / UTM zone {zone_number}N\",\n                \"datum\": \"Adindan\",\n            }\n        )\n\n    return suggestions\n</code></pre>"},{"location":"api/crs/#sudapy.crs.registry.validate_epsg","title":"validate_epsg","text":"<pre><code>validate_epsg(epsg: int) -&gt; CRS\n</code></pre> <p>Return a :class:<code>pyproj.CRS</code> for the given EPSG code or raise.</p> <p>Parameters:</p> Name Type Description Default <code>epsg</code> <code>int</code> <p>EPSG code.</p> required <p>Returns:</p> Type Description <code>CRS</code> <p>A <code>pyproj.CRS</code> instance.</p> <p>Raises:</p> Type Description <code>CRSError</code> <p>If the EPSG code is invalid.</p> Source code in <code>src\\sudapy\\crs\\registry.py</code> <pre><code>def validate_epsg(epsg: int) -&gt; CRS:\n    \"\"\"Return a :class:`pyproj.CRS` for the given EPSG code or raise.\n\n    Args:\n        epsg: EPSG code.\n\n    Returns:\n        A ``pyproj.CRS`` instance.\n\n    Raises:\n        sudapy.core.errors.CRSError: If the EPSG code is invalid.\n    \"\"\"\n    from sudapy.core.errors import CRSError\n\n    try:\n        return CRS.from_epsg(epsg)\n    except Exception as exc:\n        raise CRSError(\n            f\"Invalid EPSG code: {epsg}\",\n            hint=\"Use 'sudapy crs list' to see common Sudan CRS presets.\",\n        ) from exc\n</code></pre>"},{"location":"api/errors/","title":"sudapy.core.errors","text":"<p>Custom exceptions with user-friendly hints.</p>"},{"location":"api/errors/#sudapy.core.errors","title":"sudapy.core.errors","text":"<p>Custom exceptions for SudaPy.</p>"},{"location":"api/errors/#sudapy.core.errors.SudaPyError","title":"SudaPyError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for all SudaPy errors.</p> Source code in <code>src\\sudapy\\core\\errors.py</code> <pre><code>class SudaPyError(Exception):\n    \"\"\"Base exception for all SudaPy errors.\"\"\"\n\n    def __init__(self, message: str, hint: str | None = None) -&gt; None:\n        self.hint = hint\n        full = message\n        if hint:\n            full += f\"\\n  Hint: {hint}\"\n        super().__init__(full)\n</code></pre>"},{"location":"api/errors/#sudapy.core.errors.CRSError","title":"CRSError","text":"<p>               Bases: <code>SudaPyError</code></p> <p>Raised for CRS-related issues (invalid EPSG, unsupported datum, etc.).</p> Source code in <code>src\\sudapy\\core\\errors.py</code> <pre><code>class CRSError(SudaPyError):\n    \"\"\"Raised for CRS-related issues (invalid EPSG, unsupported datum, etc.).\"\"\"\n</code></pre>"},{"location":"api/errors/#sudapy.core.errors.FileFormatError","title":"FileFormatError","text":"<p>               Bases: <code>SudaPyError</code></p> <p>Raised when an input file has an unsupported or invalid format.</p> Source code in <code>src\\sudapy\\core\\errors.py</code> <pre><code>class FileFormatError(SudaPyError):\n    \"\"\"Raised when an input file has an unsupported or invalid format.\"\"\"\n</code></pre>"},{"location":"api/errors/#sudapy.core.errors.DependencyError","title":"DependencyError","text":"<p>               Bases: <code>SudaPyError</code></p> <p>Raised when a required optional dependency is missing.</p> Source code in <code>src\\sudapy\\core\\errors.py</code> <pre><code>class DependencyError(SudaPyError):\n    \"\"\"Raised when a required optional dependency is missing.\"\"\"\n</code></pre>"},{"location":"api/errors/#sudapy.core.errors.check_import","title":"check_import","text":"<pre><code>check_import(module: str, extra: str = '') -&gt; None\n</code></pre> <p>Import module or raise :class:<code>DependencyError</code> with install hint.</p> <p>Parameters:</p> Name Type Description Default <code>module</code> <code>str</code> <p>Dotted module name.</p> required <code>extra</code> <code>str</code> <p>The pip extra that provides this module (e.g. <code>\"viz\"</code>).</p> <code>''</code> Source code in <code>src\\sudapy\\core\\errors.py</code> <pre><code>def check_import(module: str, extra: str = \"\") -&gt; None:\n    \"\"\"Import *module* or raise :class:`DependencyError` with install hint.\n\n    Args:\n        module: Dotted module name.\n        extra: The pip extra that provides this module (e.g. ``\"viz\"``).\n    \"\"\"\n    try:\n        __import__(module)\n    except ImportError as exc:\n        hint = f'pip install \"sudapy[{extra}]\"' if extra else f\"pip install {module}\"\n        raise DependencyError(\n            f\"Missing dependency: {module}\",\n            hint=hint,\n        ) from exc\n</code></pre>"},{"location":"api/raster/","title":"sudapy.raster.ops","text":"<p>Raster geoprocessing operations: clip, reproject, resample, mosaic, hillshade, slope.</p>"},{"location":"api/raster/#sudapy.raster.ops","title":"sudapy.raster.ops","text":"<p>Raster geoprocessing operations.</p> <p>Functions wrap :mod:<code>rasterio</code> to provide high-level raster processing capabilities: clip, reproject, resample, mosaic, hillshade, and slope.</p>"},{"location":"api/raster/#sudapy.raster.ops.clip","title":"clip","text":"<pre><code>clip(src: PathLike, clip_vector: PathLike, out: PathLike, *, crop: bool = True, nodata: float | None = None) -&gt; Path\n</code></pre> <p>Clip a raster by vector geometries.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>PathLike</code> <p>Input raster path.</p> required <code>clip_vector</code> <code>PathLike</code> <p>Vector file whose geometries define the clip extent.</p> required <code>out</code> <code>PathLike</code> <p>Output raster path.</p> required <code>crop</code> <code>bool</code> <p>Whether to crop the raster extent to the vector bounds.</p> <code>True</code> <code>nodata</code> <code>float | None</code> <p>NoData value for masked pixels. Defaults to the source nodata.</p> <code>None</code> <p>Returns:</p> Type Description <code>Path</code> <p>Path to the output raster.</p> Source code in <code>src\\sudapy\\raster\\ops.py</code> <pre><code>def clip(\n    src: PathLike,\n    clip_vector: PathLike,\n    out: PathLike,\n    *,\n    crop: bool = True,\n    nodata: float | None = None,\n) -&gt; Path:\n    \"\"\"Clip a raster by vector geometries.\n\n    Args:\n        src: Input raster path.\n        clip_vector: Vector file whose geometries define the clip extent.\n        out: Output raster path.\n        crop: Whether to crop the raster extent to the vector bounds.\n        nodata: NoData value for masked pixels. Defaults to the source nodata.\n\n    Returns:\n        Path to the output raster.\n    \"\"\"\n    src = Path(src)\n    out = Path(out)\n    if not src.exists():\n        raise FileFormatError(f\"Raster not found: {src}\")\n\n    mask_gdf = read_vector(clip_vector)\n\n    with rasterio.open(src) as ds:\n        if mask_gdf.crs and mask_gdf.crs != ds.crs:\n            logger.info(\"Reprojecting clip vector to raster CRS (%s)\", ds.crs)\n            mask_gdf = mask_gdf.to_crs(ds.crs)\n\n        geometries = mask_gdf.geometry.values\n        nd = nodata if nodata is not None else ds.nodata\n\n        out_image, out_transform = rasterio.mask.mask(\n            ds, geometries, crop=crop, nodata=nd,\n        )\n        out_meta = ds.meta.copy()\n        out_meta.update({\n            \"driver\": \"GTiff\",\n            \"height\": out_image.shape[1],\n            \"width\": out_image.shape[2],\n            \"transform\": out_transform,\n            \"nodata\": nd,\n        })\n\n    out.parent.mkdir(parents=True, exist_ok=True)\n    with rasterio.open(out, \"w\", **out_meta) as dst:\n        dst.write(out_image)\n\n    logger.info(\"Clipped raster written to %s\", out)\n    return out\n</code></pre>"},{"location":"api/raster/#sudapy.raster.ops.reproject_raster","title":"reproject_raster","text":"<pre><code>reproject_raster(src: PathLike, out: PathLike, to_epsg: int, *, resampling: Resampling = Resampling.nearest) -&gt; Path\n</code></pre> <p>Reproject a raster to a new CRS.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>PathLike</code> <p>Input raster path.</p> required <code>out</code> <code>PathLike</code> <p>Output raster path.</p> required <code>to_epsg</code> <code>int</code> <p>Target EPSG code.</p> required <code>resampling</code> <code>Resampling</code> <p>Resampling method.</p> <code>nearest</code> <p>Returns:</p> Type Description <code>Path</code> <p>Path to the output raster.</p> Source code in <code>src\\sudapy\\raster\\ops.py</code> <pre><code>def reproject_raster(\n    src: PathLike,\n    out: PathLike,\n    to_epsg: int,\n    *,\n    resampling: Resampling = Resampling.nearest,\n) -&gt; Path:\n    \"\"\"Reproject a raster to a new CRS.\n\n    Args:\n        src: Input raster path.\n        out: Output raster path.\n        to_epsg: Target EPSG code.\n        resampling: Resampling method.\n\n    Returns:\n        Path to the output raster.\n    \"\"\"\n    src = Path(src)\n    out = Path(out)\n    if not src.exists():\n        raise FileFormatError(f\"Raster not found: {src}\")\n\n    dst_crs = validate_epsg(to_epsg)\n\n    with rasterio.open(src) as ds:\n        transform, width, height = calculate_default_transform(\n            ds.crs, dst_crs, ds.width, ds.height, *ds.bounds\n        )\n        kwargs = ds.meta.copy()\n        kwargs.update({\n            \"crs\": dst_crs,\n            \"transform\": transform,\n            \"width\": width,\n            \"height\": height,\n            \"driver\": \"GTiff\",\n        })\n\n        out.parent.mkdir(parents=True, exist_ok=True)\n        with rasterio.open(out, \"w\", **kwargs) as dst:\n            for i in range(1, ds.count + 1):\n                reproject(\n                    source=rasterio.band(ds, i),\n                    destination=rasterio.band(dst, i),\n                    src_transform=ds.transform,\n                    src_crs=ds.crs,\n                    dst_transform=transform,\n                    dst_crs=dst_crs,\n                    resampling=resampling,\n                )\n\n    logger.info(\"Reprojected raster written to %s\", out)\n    return out\n</code></pre>"},{"location":"api/raster/#sudapy.raster.ops.resample","title":"resample","text":"<pre><code>resample(src: PathLike, out: PathLike, scale_factor: float, method: str = 'bilinear') -&gt; Path\n</code></pre> <p>Resample a raster by a scale factor.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>PathLike</code> <p>Input raster path.</p> required <code>out</code> <code>PathLike</code> <p>Output raster path.</p> required <code>scale_factor</code> <code>float</code> <p>Factor to scale resolution (2.0 = double resolution).</p> required <code>method</code> <code>str</code> <p>Resampling method name: <code>nearest</code>, <code>bilinear</code>, <code>cubic</code>.</p> <code>'bilinear'</code> <p>Returns:</p> Type Description <code>Path</code> <p>Path to the output raster.</p> Source code in <code>src\\sudapy\\raster\\ops.py</code> <pre><code>def resample(\n    src: PathLike,\n    out: PathLike,\n    scale_factor: float,\n    method: str = \"bilinear\",\n) -&gt; Path:\n    \"\"\"Resample a raster by a scale factor.\n\n    Args:\n        src: Input raster path.\n        out: Output raster path.\n        scale_factor: Factor to scale resolution (2.0 = double resolution).\n        method: Resampling method name: ``nearest``, ``bilinear``, ``cubic``.\n\n    Returns:\n        Path to the output raster.\n    \"\"\"\n    src = Path(src)\n    out = Path(out)\n    if not src.exists():\n        raise FileFormatError(f\"Raster not found: {src}\")\n\n    resampling_method = _RESAMPLING_MAP.get(method)\n    if resampling_method is None:\n        raise SudaPyError(\n            f\"Unknown resampling method '{method}'\",\n            hint=f\"Supported: {', '.join(_RESAMPLING_MAP.keys())}\",\n        )\n\n    with rasterio.open(src) as ds:\n        new_height = int(ds.height * scale_factor)\n        new_width = int(ds.width * scale_factor)\n\n        data = ds.read(\n            out_shape=(ds.count, new_height, new_width),\n            resampling=resampling_method,\n        )\n\n        transform = ds.transform * ds.transform.scale(\n            ds.width / new_width,\n            ds.height / new_height,\n        )\n\n        kwargs = ds.meta.copy()\n        kwargs.update({\n            \"driver\": \"GTiff\",\n            \"height\": new_height,\n            \"width\": new_width,\n            \"transform\": transform,\n        })\n\n    out.parent.mkdir(parents=True, exist_ok=True)\n    with rasterio.open(out, \"w\", **kwargs) as dst:\n        dst.write(data)\n\n    logger.info(\"Resampled raster (x%.1f, %s) written to %s\", scale_factor, method, out)\n    return out\n</code></pre>"},{"location":"api/raster/#sudapy.raster.ops.mosaic","title":"mosaic","text":"<pre><code>mosaic(src_dir: PathLike, out: PathLike) -&gt; Path\n</code></pre> <p>Merge multiple raster tiles from a directory into one.</p> <p>Parameters:</p> Name Type Description Default <code>src_dir</code> <code>PathLike</code> <p>Directory containing raster tiles.</p> required <code>out</code> <code>PathLike</code> <p>Output merged raster path.</p> required <p>Returns:</p> Type Description <code>Path</code> <p>Path to the merged raster.</p> Source code in <code>src\\sudapy\\raster\\ops.py</code> <pre><code>def mosaic(\n    src_dir: PathLike,\n    out: PathLike,\n) -&gt; Path:\n    \"\"\"Merge multiple raster tiles from a directory into one.\n\n    Args:\n        src_dir: Directory containing raster tiles.\n        out: Output merged raster path.\n\n    Returns:\n        Path to the merged raster.\n    \"\"\"\n    src_dir = Path(src_dir)\n    out = Path(out)\n    if not src_dir.is_dir():\n        raise FileFormatError(f\"Not a directory: {src_dir}\")\n\n    raster_files = sorted(\n        f for f in src_dir.iterdir() if f.suffix.lower() in _RASTER_EXTS\n    )\n    if not raster_files:\n        raise FileFormatError(\n            f\"No raster files found in {src_dir}\",\n            hint=f\"Supported extensions: {', '.join(_RASTER_EXTS)}\",\n        )\n\n    datasets = [rasterio.open(f) for f in raster_files]\n    try:\n        mosaic_data, mosaic_transform = merge(datasets)\n    finally:\n        for ds in datasets:\n            ds.close()\n\n    kwargs = datasets[0].meta.copy()\n    kwargs.update({\n        \"driver\": \"GTiff\",\n        \"height\": mosaic_data.shape[1],\n        \"width\": mosaic_data.shape[2],\n        \"transform\": mosaic_transform,\n    })\n\n    out.parent.mkdir(parents=True, exist_ok=True)\n    with rasterio.open(out, \"w\", **kwargs) as dst:\n        dst.write(mosaic_data)\n\n    logger.info(\"Mosaic of %d tiles written to %s\", len(raster_files), out)\n    return out\n</code></pre>"},{"location":"api/raster/#sudapy.raster.ops.hillshade","title":"hillshade","text":"<pre><code>hillshade(src: PathLike, out: PathLike, *, azimuth: float = 315.0, altitude: float = 45.0) -&gt; Path\n</code></pre> <p>Generate a hillshade from a DEM raster.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>PathLike</code> <p>Input DEM raster path (single band, elevation values).</p> required <code>out</code> <code>PathLike</code> <p>Output hillshade raster path.</p> required <code>azimuth</code> <code>float</code> <p>Sun azimuth in degrees (default 315 = northwest).</p> <code>315.0</code> <code>altitude</code> <code>float</code> <p>Sun altitude in degrees above horizon (default 45).</p> <code>45.0</code> <p>Returns:</p> Type Description <code>Path</code> <p>Path to the hillshade raster.</p> Source code in <code>src\\sudapy\\raster\\ops.py</code> <pre><code>def hillshade(\n    src: PathLike,\n    out: PathLike,\n    *,\n    azimuth: float = 315.0,\n    altitude: float = 45.0,\n) -&gt; Path:\n    \"\"\"Generate a hillshade from a DEM raster.\n\n    Args:\n        src: Input DEM raster path (single band, elevation values).\n        out: Output hillshade raster path.\n        azimuth: Sun azimuth in degrees (default 315 = northwest).\n        altitude: Sun altitude in degrees above horizon (default 45).\n\n    Returns:\n        Path to the hillshade raster.\n    \"\"\"\n    src = Path(src)\n    out = Path(out)\n    if not src.exists():\n        raise FileFormatError(f\"Raster not found: {src}\")\n\n    with rasterio.open(src) as ds:\n        dem = ds.read(1).astype(np.float64)\n        cellsize_x = abs(ds.transform.a)\n        cellsize_y = abs(ds.transform.e)\n\n        hs = _compute_hillshade(dem, cellsize_x, cellsize_y, azimuth, altitude)\n\n        kwargs = ds.meta.copy()\n        kwargs.update({\n            \"driver\": \"GTiff\",\n            \"dtype\": \"float32\",\n            \"count\": 1,\n        })\n\n    out.parent.mkdir(parents=True, exist_ok=True)\n    with rasterio.open(out, \"w\", **kwargs) as dst:\n        dst.write(hs.astype(np.float32), 1)\n\n    logger.info(\"Hillshade written to %s\", out)\n    return out\n</code></pre>"},{"location":"api/raster/#sudapy.raster.ops.slope","title":"slope","text":"<pre><code>slope(src: PathLike, out: PathLike) -&gt; Path\n</code></pre> <p>Calculate slope in degrees from a DEM raster.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>PathLike</code> <p>Input DEM raster path (single band).</p> required <code>out</code> <code>PathLike</code> <p>Output slope raster path (values in degrees).</p> required <p>Returns:</p> Type Description <code>Path</code> <p>Path to the slope raster.</p> Source code in <code>src\\sudapy\\raster\\ops.py</code> <pre><code>def slope(\n    src: PathLike,\n    out: PathLike,\n) -&gt; Path:\n    \"\"\"Calculate slope in degrees from a DEM raster.\n\n    Args:\n        src: Input DEM raster path (single band).\n        out: Output slope raster path (values in degrees).\n\n    Returns:\n        Path to the slope raster.\n    \"\"\"\n    src = Path(src)\n    out = Path(out)\n    if not src.exists():\n        raise FileFormatError(f\"Raster not found: {src}\")\n\n    with rasterio.open(src) as ds:\n        dem = ds.read(1).astype(np.float64)\n        cellsize_x = abs(ds.transform.a)\n        cellsize_y = abs(ds.transform.e)\n\n        slope_deg = _compute_slope(dem, cellsize_x, cellsize_y)\n\n        kwargs = ds.meta.copy()\n        kwargs.update({\n            \"driver\": \"GTiff\",\n            \"dtype\": \"float32\",\n            \"count\": 1,\n        })\n\n    out.parent.mkdir(parents=True, exist_ok=True)\n    with rasterio.open(out, \"w\", **kwargs) as dst:\n        dst.write(slope_deg.astype(np.float32), 1)\n\n    logger.info(\"Slope raster written to %s\", out)\n    return out\n</code></pre>"},{"location":"api/sentinel/","title":"sudapy.rs.sentinel","text":"<p>Sentinel satellite scene search and download via sentinelsat.</p> <p>Note</p> <p>Requires <code>pip install \"sudapy[rs]\"</code> and Copernicus credentials set as environment variables.</p>"},{"location":"api/sentinel/#sudapy.rs.sentinel","title":"sudapy.rs.sentinel","text":"<p>Sentinel satellite scene search and download via sentinelsat.</p> <p>Requires the <code>sudapy[rs]</code> extra:  <code>pip install \"sudapy[rs]\"</code></p> <p>Before first use, set your Copernicus Open Access Hub credentials:</p> <pre><code>export COPERNICUS_USER=your_username\nexport COPERNICUS_PASSWORD=your_password\n</code></pre> <p>Register at https://scihub.copernicus.eu/dhus/#/self-registration</p>"},{"location":"api/sentinel/#sudapy.rs.sentinel.search_scenes","title":"search_scenes","text":"<pre><code>search_scenes(*, lon: float, lat: float, start_date: str, end_date: str, platform_name: str = 'Sentinel-2', max_cloud: int = 30) -&gt; list[dict]\n</code></pre> <p>Search for Sentinel scenes around a point.</p> <p>Parameters:</p> Name Type Description Default <code>lon</code> <code>float</code> <p>Center longitude.</p> required <code>lat</code> <code>float</code> <p>Center latitude.</p> required <code>start_date</code> <code>str</code> <p>Start date as YYYY-MM-DD.</p> required <code>end_date</code> <code>str</code> <p>End date as YYYY-MM-DD.</p> required <code>platform_name</code> <code>str</code> <p>Satellite platform (default <code>Sentinel-2</code>).</p> <code>'Sentinel-2'</code> <code>max_cloud</code> <code>int</code> <p>Maximum cloud cover percentage (default 30).</p> <code>30</code> <p>Returns:</p> Type Description <code>list[dict]</code> <p>List of dicts with keys: <code>uuid</code>, <code>title</code>, <code>date</code>, <code>cloud_cover</code>.</p> Source code in <code>src\\sudapy\\rs\\sentinel.py</code> <pre><code>def search_scenes(\n    *,\n    lon: float,\n    lat: float,\n    start_date: str,\n    end_date: str,\n    platform_name: str = \"Sentinel-2\",\n    max_cloud: int = 30,\n) -&gt; list[dict]:\n    \"\"\"Search for Sentinel scenes around a point.\n\n    Args:\n        lon: Center longitude.\n        lat: Center latitude.\n        start_date: Start date as YYYY-MM-DD.\n        end_date: End date as YYYY-MM-DD.\n        platform_name: Satellite platform (default ``Sentinel-2``).\n        max_cloud: Maximum cloud cover percentage (default 30).\n\n    Returns:\n        List of dicts with keys: ``uuid``, ``title``, ``date``, ``cloud_cover``.\n    \"\"\"\n    from sentinelsat import geojson_to_wkt, read_geojson\n\n    api = _get_api()\n\n    # Create a small point footprint\n    footprint = f\"POINT({lon} {lat})\"\n\n    products = api.query(\n        footprint,\n        date=(start_date.replace(\"-\", \"\"), end_date.replace(\"-\", \"\")),\n        platformname=platform_name,\n        cloudcoverpercentage=(0, max_cloud),\n    )\n\n    results = []\n    for uid, meta in products.items():\n        results.append({\n            \"uuid\": uid,\n            \"title\": meta.get(\"title\", \"\"),\n            \"date\": str(meta.get(\"beginposition\", \"\"))[:10],\n            \"cloud_cover\": meta.get(\"cloudcoverpercentage\", -1),\n        })\n\n    # Sort by date descending\n    results.sort(key=lambda r: r[\"date\"], reverse=True)\n    logger.info(\"Found %d scenes\", len(results))\n    return results\n</code></pre>"},{"location":"api/sentinel/#sudapy.rs.sentinel.download_scene","title":"download_scene","text":"<pre><code>download_scene(*, uuid: str, out_dir: PathLike = '.') -&gt; Path\n</code></pre> <p>Download a Sentinel scene by UUID.</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>str</code> <p>Scene UUID from :func:<code>search_scenes</code>.</p> required <code>out_dir</code> <code>PathLike</code> <p>Output directory (default: current directory).</p> <code>'.'</code> <p>Returns:</p> Type Description <code>Path</code> <p>Path to the downloaded file.</p> Source code in <code>src\\sudapy\\rs\\sentinel.py</code> <pre><code>def download_scene(\n    *,\n    uuid: str,\n    out_dir: PathLike = \".\",\n) -&gt; Path:\n    \"\"\"Download a Sentinel scene by UUID.\n\n    Args:\n        uuid: Scene UUID from :func:`search_scenes`.\n        out_dir: Output directory (default: current directory).\n\n    Returns:\n        Path to the downloaded file.\n    \"\"\"\n    api = _get_api()\n    out_dir = Path(out_dir)\n    out_dir.mkdir(parents=True, exist_ok=True)\n\n    logger.info(\"Downloading scene %s to %s ...\", uuid, out_dir)\n    result = api.download(uuid, directory_path=str(out_dir))\n\n    downloaded_path = Path(result[\"path\"])\n    logger.info(\"Download complete: %s\", downloaded_path)\n    return downloaded_path\n</code></pre>"},{"location":"api/vector/","title":"sudapy.vector.ops","text":"<p>Vector geoprocessing operations: reproject, clip, dissolve, area, buffer, simplify, fix-geometry.</p>"},{"location":"api/vector/#sudapy.vector.ops","title":"sudapy.vector.ops","text":"<p>Vector geoprocessing operations.</p> <p>All functions accept and return :class:<code>geopandas.GeoDataFrame</code> objects and support GeoPackage, GeoJSON, and Shapefile formats on disk.</p>"},{"location":"api/vector/#sudapy.vector.ops.reproject","title":"reproject","text":"<pre><code>reproject(src: PathLike | GeoDataFrame, to_epsg: int, out: PathLike | None = None) -&gt; gpd.GeoDataFrame\n</code></pre> <p>Reproject a vector dataset to a new CRS.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>PathLike | GeoDataFrame</code> <p>Input file path or GeoDataFrame.</p> required <code>to_epsg</code> <code>int</code> <p>Target EPSG code.</p> required <code>out</code> <code>PathLike | None</code> <p>Optional output file path. If given the result is also saved.</p> <code>None</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>Reprojected GeoDataFrame.</p> Source code in <code>src\\sudapy\\vector\\ops.py</code> <pre><code>def reproject(\n    src: PathLike | gpd.GeoDataFrame,\n    to_epsg: int,\n    out: PathLike | None = None,\n) -&gt; gpd.GeoDataFrame:\n    \"\"\"Reproject a vector dataset to a new CRS.\n\n    Args:\n        src: Input file path or GeoDataFrame.\n        to_epsg: Target EPSG code.\n        out: Optional output file path. If given the result is also saved.\n\n    Returns:\n        Reprojected GeoDataFrame.\n    \"\"\"\n    gdf = _read(src) if not isinstance(src, gpd.GeoDataFrame) else src\n    target_crs = validate_epsg(to_epsg)\n    result = gdf.to_crs(target_crs)\n    if out is not None:\n        _write(result, out)\n    return result\n</code></pre>"},{"location":"api/vector/#sudapy.vector.ops.clip","title":"clip","text":"<pre><code>clip(src: PathLike | GeoDataFrame, clip_src: PathLike | GeoDataFrame, out: PathLike | None = None) -&gt; gpd.GeoDataFrame\n</code></pre> <p>Clip a vector dataset by another vector geometry.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>PathLike | GeoDataFrame</code> <p>Input file or GeoDataFrame.</p> required <code>clip_src</code> <code>PathLike | GeoDataFrame</code> <p>Clipping geometry file or GeoDataFrame.</p> required <code>out</code> <code>PathLike | None</code> <p>Optional output path.</p> <code>None</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>Clipped GeoDataFrame.</p> Source code in <code>src\\sudapy\\vector\\ops.py</code> <pre><code>def clip(\n    src: PathLike | gpd.GeoDataFrame,\n    clip_src: PathLike | gpd.GeoDataFrame,\n    out: PathLike | None = None,\n) -&gt; gpd.GeoDataFrame:\n    \"\"\"Clip a vector dataset by another vector geometry.\n\n    Args:\n        src: Input file or GeoDataFrame.\n        clip_src: Clipping geometry file or GeoDataFrame.\n        out: Optional output path.\n\n    Returns:\n        Clipped GeoDataFrame.\n    \"\"\"\n    gdf = _read(src) if not isinstance(src, gpd.GeoDataFrame) else src\n    mask = _read(clip_src) if not isinstance(clip_src, gpd.GeoDataFrame) else clip_src\n\n    # Ensure same CRS\n    if gdf.crs and mask.crs and gdf.crs != mask.crs:\n        logger.info(\"Reprojecting clip geometry to match input CRS (%s)\", gdf.crs)\n        mask = mask.to_crs(gdf.crs)\n\n    result = gpd.clip(gdf, mask)\n    if out is not None:\n        _write(result, out)\n    return result\n</code></pre>"},{"location":"api/vector/#sudapy.vector.ops.dissolve","title":"dissolve","text":"<pre><code>dissolve(src: PathLike | GeoDataFrame, by: str, out: PathLike | None = None) -&gt; gpd.GeoDataFrame\n</code></pre> <p>Dissolve geometries by an attribute field.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>PathLike | GeoDataFrame</code> <p>Input file or GeoDataFrame.</p> required <code>by</code> <code>str</code> <p>Column name to dissolve on.</p> required <code>out</code> <code>PathLike | None</code> <p>Optional output path.</p> <code>None</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>Dissolved GeoDataFrame.</p> Source code in <code>src\\sudapy\\vector\\ops.py</code> <pre><code>def dissolve(\n    src: PathLike | gpd.GeoDataFrame,\n    by: str,\n    out: PathLike | None = None,\n) -&gt; gpd.GeoDataFrame:\n    \"\"\"Dissolve geometries by an attribute field.\n\n    Args:\n        src: Input file or GeoDataFrame.\n        by: Column name to dissolve on.\n        out: Optional output path.\n\n    Returns:\n        Dissolved GeoDataFrame.\n    \"\"\"\n    gdf = _read(src) if not isinstance(src, gpd.GeoDataFrame) else src\n    if by not in gdf.columns:\n        raise SudaPyError(\n            f\"Column '{by}' not found in dataset.\",\n            hint=f\"Available columns: {', '.join(gdf.columns.tolist())}\",\n        )\n    result = gdf.dissolve(by=by).reset_index()\n    if out is not None:\n        _write(result, out)\n    return result\n</code></pre>"},{"location":"api/vector/#sudapy.vector.ops.calculate_area","title":"calculate_area","text":"<pre><code>calculate_area(src: PathLike | GeoDataFrame, field: str = 'area_m2', out: PathLike | None = None) -&gt; gpd.GeoDataFrame\n</code></pre> <p>Calculate geometry area in square meters.</p> <p>If the CRS is geographic (lat/lon) a warning is emitted and geometries are temporarily projected to the appropriate UTM zone for accurate area calculation.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>PathLike | GeoDataFrame</code> <p>Input file or GeoDataFrame.</p> required <code>field</code> <code>str</code> <p>Name of the new area column.</p> <code>'area_m2'</code> <code>out</code> <code>PathLike | None</code> <p>Optional output path.</p> <code>None</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>GeoDataFrame with a new area column.</p> Source code in <code>src\\sudapy\\vector\\ops.py</code> <pre><code>def calculate_area(\n    src: PathLike | gpd.GeoDataFrame,\n    field: str = \"area_m2\",\n    out: PathLike | None = None,\n) -&gt; gpd.GeoDataFrame:\n    \"\"\"Calculate geometry area in square meters.\n\n    If the CRS is geographic (lat/lon) a warning is emitted and geometries\n    are temporarily projected to the appropriate UTM zone for accurate\n    area calculation.\n\n    Args:\n        src: Input file or GeoDataFrame.\n        field: Name of the new area column.\n        out: Optional output path.\n\n    Returns:\n        GeoDataFrame with a new area column.\n    \"\"\"\n    gdf = _read(src) if not isinstance(src, gpd.GeoDataFrame) else src.copy()\n\n    if gdf.crs is None:\n        raise CRSError(\n            \"Input dataset has no CRS.\",\n            hint=\"Set a CRS first, e.g. 'sudapy vector reproject --in file --out file --to 32635'.\",\n        )\n\n    if gdf.crs.is_geographic:\n        warnings.warn(\n            \"Input CRS is geographic (lat/lon). Area will be computed by \"\n            \"temporarily projecting to the estimated UTM zone. For best \"\n            \"accuracy, reproject your data to a projected CRS first.\",\n            UserWarning,\n            stacklevel=2,\n        )\n        projected = gdf.to_crs(gdf.estimate_utm_crs())\n        gdf[field] = projected.geometry.area\n    else:\n        gdf[field] = gdf.geometry.area\n\n    if out is not None:\n        _write(gdf, out)\n    return gdf\n</code></pre>"},{"location":"api/vector/#sudapy.vector.ops.buffer","title":"buffer","text":"<pre><code>buffer(src: PathLike | GeoDataFrame, distance_m: float, out: PathLike | None = None) -&gt; gpd.GeoDataFrame\n</code></pre> <p>Buffer geometries by a distance in meters.</p> <p>If the CRS is geographic, the data is temporarily projected to the estimated UTM zone so the buffer distance is applied in meters.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>PathLike | GeoDataFrame</code> <p>Input file or GeoDataFrame.</p> required <code>distance_m</code> <code>float</code> <p>Buffer distance in meters.</p> required <code>out</code> <code>PathLike | None</code> <p>Optional output path.</p> <code>None</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>Buffered GeoDataFrame (in original CRS).</p> Source code in <code>src\\sudapy\\vector\\ops.py</code> <pre><code>def buffer(\n    src: PathLike | gpd.GeoDataFrame,\n    distance_m: float,\n    out: PathLike | None = None,\n) -&gt; gpd.GeoDataFrame:\n    \"\"\"Buffer geometries by a distance in meters.\n\n    If the CRS is geographic, the data is temporarily projected to the\n    estimated UTM zone so the buffer distance is applied in meters.\n\n    Args:\n        src: Input file or GeoDataFrame.\n        distance_m: Buffer distance in meters.\n        out: Optional output path.\n\n    Returns:\n        Buffered GeoDataFrame (in original CRS).\n    \"\"\"\n    gdf = _read(src) if not isinstance(src, gpd.GeoDataFrame) else src\n    original_crs = gdf.crs\n\n    if original_crs is None:\n        raise CRSError(\n            \"Input dataset has no CRS.\",\n            hint=\"Set a CRS so the buffer distance can be applied in meters.\",\n        )\n\n    if original_crs.is_geographic:\n        warnings.warn(\n            \"Input CRS is geographic. Temporarily projecting to UTM for \"\n            \"accurate meter-based buffering.\",\n            UserWarning,\n            stacklevel=2,\n        )\n        projected = gdf.to_crs(gdf.estimate_utm_crs())\n        projected[\"geometry\"] = projected.geometry.buffer(distance_m)\n        result = projected.to_crs(original_crs)\n    else:\n        result = gdf.copy()\n        result[\"geometry\"] = result.geometry.buffer(distance_m)\n\n    if out is not None:\n        _write(result, out)\n    return result\n</code></pre>"},{"location":"api/vector/#sudapy.vector.ops.simplify","title":"simplify","text":"<pre><code>simplify(src: PathLike | GeoDataFrame, tolerance_m: float, out: PathLike | None = None) -&gt; gpd.GeoDataFrame\n</code></pre> <p>Simplify geometries to reduce vertex count.</p> <p>If the CRS is geographic, the data is temporarily projected to UTM so the tolerance is applied in meters.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>PathLike | GeoDataFrame</code> <p>Input file or GeoDataFrame.</p> required <code>tolerance_m</code> <code>float</code> <p>Simplification tolerance in meters.</p> required <code>out</code> <code>PathLike | None</code> <p>Optional output path.</p> <code>None</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>Simplified GeoDataFrame.</p> Source code in <code>src\\sudapy\\vector\\ops.py</code> <pre><code>def simplify(\n    src: PathLike | gpd.GeoDataFrame,\n    tolerance_m: float,\n    out: PathLike | None = None,\n) -&gt; gpd.GeoDataFrame:\n    \"\"\"Simplify geometries to reduce vertex count.\n\n    If the CRS is geographic, the data is temporarily projected to UTM\n    so the tolerance is applied in meters.\n\n    Args:\n        src: Input file or GeoDataFrame.\n        tolerance_m: Simplification tolerance in meters.\n        out: Optional output path.\n\n    Returns:\n        Simplified GeoDataFrame.\n    \"\"\"\n    gdf = _read(src) if not isinstance(src, gpd.GeoDataFrame) else src\n    original_crs = gdf.crs\n\n    if original_crs and original_crs.is_geographic:\n        projected = gdf.to_crs(gdf.estimate_utm_crs())\n        projected[\"geometry\"] = projected.geometry.simplify(tolerance_m)\n        result = projected.to_crs(original_crs)\n    else:\n        result = gdf.copy()\n        result[\"geometry\"] = result.geometry.simplify(tolerance_m)\n\n    if out is not None:\n        _write(result, out)\n    return result\n</code></pre>"},{"location":"api/vector/#sudapy.vector.ops.fix_geometry","title":"fix_geometry","text":"<pre><code>fix_geometry(src: PathLike | GeoDataFrame, out: PathLike | None = None) -&gt; gpd.GeoDataFrame\n</code></pre> <p>Repair invalid geometries using :func:<code>shapely.validation.make_valid</code>.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>PathLike | GeoDataFrame</code> <p>Input file or GeoDataFrame.</p> required <code>out</code> <code>PathLike | None</code> <p>Optional output path.</p> <code>None</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>GeoDataFrame with all geometries made valid.</p> Source code in <code>src\\sudapy\\vector\\ops.py</code> <pre><code>def fix_geometry(\n    src: PathLike | gpd.GeoDataFrame,\n    out: PathLike | None = None,\n) -&gt; gpd.GeoDataFrame:\n    \"\"\"Repair invalid geometries using :func:`shapely.validation.make_valid`.\n\n    Args:\n        src: Input file or GeoDataFrame.\n        out: Optional output path.\n\n    Returns:\n        GeoDataFrame with all geometries made valid.\n    \"\"\"\n    gdf = _read(src) if not isinstance(src, gpd.GeoDataFrame) else src.copy()\n\n    invalid_count = int((~gdf.geometry.is_valid).sum())\n    if invalid_count &gt; 0:\n        logger.info(\"Fixing %d invalid geometries\", invalid_count)\n        gdf[\"geometry\"] = gdf.geometry.apply(\n            lambda g: make_valid(g) if g is not None and not g.is_valid else g\n        )\n    else:\n        logger.info(\"All geometries are already valid\")\n\n    if out is not None:\n        _write(gdf, out)\n    return gdf\n</code></pre>"},{"location":"api/viz/","title":"sudapy.viz.maps","text":"<p>Quick map visualization: export vector or raster data to PNG or interactive HTML.</p>"},{"location":"api/viz/#sudapy.viz.maps","title":"sudapy.viz.maps","text":"<p>Quick map visualization helpers.</p> <p>Supports exporting vector or raster data to PNG (static) or HTML (interactive).</p>"},{"location":"api/viz/#sudapy.viz.maps.quick_map","title":"quick_map","text":"<pre><code>quick_map(src: PathLike, out: PathLike, *, title: str | None = None) -&gt; Path\n</code></pre> <p>Create a quick visualization of a vector or raster dataset.</p> <p>The output format is determined by the extension of out:</p> <ul> <li><code>.png</code> / <code>.jpg</code> - static image (requires matplotlib).</li> <li><code>.html</code> - interactive Leaflet map (requires folium).</li> </ul> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>PathLike</code> <p>Input vector or raster file path.</p> required <code>out</code> <code>PathLike</code> <p>Output image/HTML path.</p> required <code>title</code> <code>str | None</code> <p>Optional title for the map.</p> <code>None</code> <p>Returns:</p> Type Description <code>Path</code> <p>Path to the generated output.</p> Source code in <code>src\\sudapy\\viz\\maps.py</code> <pre><code>def quick_map(\n    src: PathLike,\n    out: PathLike,\n    *,\n    title: str | None = None,\n) -&gt; Path:\n    \"\"\"Create a quick visualization of a vector or raster dataset.\n\n    The output format is determined by the extension of *out*:\n\n    - ``.png`` / ``.jpg`` - static image (requires matplotlib).\n    - ``.html`` - interactive Leaflet map (requires folium).\n\n    Args:\n        src: Input vector or raster file path.\n        out: Output image/HTML path.\n        title: Optional title for the map.\n\n    Returns:\n        Path to the generated output.\n    \"\"\"\n    src = Path(src)\n    out = Path(out)\n    if not src.exists():\n        raise FileFormatError(f\"Input file not found: {src}\")\n\n    out.parent.mkdir(parents=True, exist_ok=True)\n\n    if out.suffix.lower() == \".html\":\n        return _export_html(src, out, title=title)\n    else:\n        return _export_static(src, out, title=title)\n</code></pre>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.9 or later</li> <li>GDAL (provided automatically by <code>rasterio</code> and <code>fiona</code>)</li> </ul> <p>Windows users</p> <p>Geospatial C libraries (GDAL, PROJ, GEOS) can be difficult to compile from source on Windows. Using conda to install binary dependencies first is strongly recommended.</p>"},{"location":"getting-started/installation/#from-pypi","title":"From PyPI","text":"<pre><code># Core toolkit\npip install sudapy\n\n# With visualization extras (matplotlib, folium, contextily)\npip install \"sudapy[viz]\"\n\n# With remote-sensing extras (earthpy, sentinelsat)\npip install \"sudapy[rs]\"\n\n# Everything\npip install \"sudapy[all]\"\n</code></pre>"},{"location":"getting-started/installation/#using-conda-recommended-for-windows","title":"Using conda (recommended for Windows)","text":"<p>Create a clean environment with the geospatial stack, then install SudaPy on top:</p> <pre><code>conda create -n sudapy python=3.11\nconda activate sudapy\nconda install -c conda-forge geopandas rasterio fiona pyproj shapely\npip install sudapy\n</code></pre> <p>A ready-made <code>environment.yml</code> is included in the repository:</p> <pre><code>git clone https://github.com/Osman-Geomatics93/sudapy.git\ncd sudapy\nconda env create -f environment.yml\nconda activate sudapy\n</code></pre>"},{"location":"getting-started/installation/#verify-the-installation","title":"Verify the installation","text":"<p>After installing, run the built-in diagnostics:</p> <pre><code>sudapy doctor\n</code></pre> <p>This checks Python version, core imports (geopandas, shapely, pyproj, rasterio, fiona), PROJ data availability, and GeoPackage read/write support.</p> <p>Expected output when everything is working:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                  SudaPy Doctor                   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Check               \u2502 Status \u2502 Details           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Python &gt;= 3.9       \u2502 PASS   \u2502 3.11.x            \u2502\n\u2502 geopandas import    \u2502 PASS   \u2502 OK                \u2502\n\u2502 shapely import      \u2502 PASS   \u2502 OK                \u2502\n\u2502 pyproj import       \u2502 PASS   \u2502 OK                \u2502\n\u2502 rasterio import     \u2502 PASS   \u2502 OK (GDAL x.y.z)   \u2502\n\u2502 fiona import        \u2502 PASS   \u2502 OK                \u2502\n\u2502 PROJ data available \u2502 PASS   \u2502 OK (WGS 84 ...)   \u2502\n\u2502 GeoPackage r/w      \u2502 PASS   \u2502 OK                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\nAll checks passed. SudaPy is ready.\n</code></pre>"},{"location":"getting-started/installation/#development-install","title":"Development install","text":"<p>To contribute or hack on SudaPy itself:</p> <pre><code>git clone https://github.com/Osman-Geomatics93/sudapy.git\ncd sudapy\npip install -e \".[dev,all]\"\npytest\nruff check src/ tests/\n</code></pre>"},{"location":"getting-started/installation/#optional-extras-reference","title":"Optional extras reference","text":"Extra Packages added Use case <code>viz</code> matplotlib, folium, contextily Map visualization (PNG/HTML) <code>rs</code> earthpy, sentinelsat Sentinel satellite search &amp; download <code>all</code> <code>viz</code> + <code>rs</code> Everything <code>dev</code> pytest, pytest-cov, ruff, mypy Development &amp; testing"},{"location":"getting-started/offline/","title":"Offline Installation","text":"<p>SudaPy supports installation in environments without internet access. This is useful for field work or restricted networks common in surveying and government contexts.</p>"},{"location":"getting-started/offline/#strategy-overview","title":"Strategy overview","text":"Method Best for Complexity Wheelhouse (pip) Pure Python + pre-built wheels Low conda pack Full environment with C libraries Medium"},{"location":"getting-started/offline/#method-1-wheelhouse-pip","title":"Method 1: Wheelhouse (pip)","text":""},{"location":"getting-started/offline/#on-a-machine-with-internet","title":"On a machine with internet","text":"<pre><code># Clone and build the wheelhouse\ngit clone https://github.com/Osman-Geomatics93/sudapy.git\ncd sudapy\npython scripts/build_wheelhouse.py\n</code></pre> <p>This downloads all wheels into a <code>wheelhouse/</code> directory. Copy the entire <code>wheelhouse/</code> folder to a USB drive.</p>"},{"location":"getting-started/offline/#on-the-offline-machine","title":"On the offline machine","text":"<pre><code>pip install --no-index --find-links=wheelhouse/ sudapy\n</code></pre> <p>Warning</p> <p>Pip wheelhouses work best when the online and offline machines have the same OS and Python version. For geospatial C libraries (GDAL, PROJ), conda is more reliable.</p>"},{"location":"getting-started/offline/#method-2-conda-environment","title":"Method 2: conda environment","text":""},{"location":"getting-started/offline/#on-a-machine-with-internet_1","title":"On a machine with internet","text":"<pre><code># Create and export the environment\nconda env create -f environment.yml\nconda activate sudapy\n\n# Pack the environment for transfer\nconda install -c conda-forge conda-pack\nconda pack -n sudapy -o sudapy-env.tar.gz\n</code></pre>"},{"location":"getting-started/offline/#on-the-offline-machine_1","title":"On the offline machine","text":"<pre><code># Unpack\nmkdir -p ~/envs/sudapy\ntar -xzf sudapy-env.tar.gz -C ~/envs/sudapy\n\n# Activate\nsource ~/envs/sudapy/bin/activate   # Linux/macOS\n# or\n~/envs/sudapy/Scripts/activate.bat  # Windows\n\n# Fix prefixes\nconda-unpack\n</code></pre>"},{"location":"getting-started/offline/#verify-offline-installation","title":"Verify offline installation","text":"<pre><code>sudapy doctor\nsudapy info\nsudapy crs list\n</code></pre> <p>All three commands should work without network access since they use only local data.</p>"},{"location":"getting-started/project-init/","title":"Project Scaffolding","text":"<p>SudaPy includes a project scaffolding command that creates a standardized folder structure for geomatics projects.</p>"},{"location":"getting-started/project-init/#create-a-new-project","title":"Create a new project","text":"<pre><code>sudapy init my_survey_project\n</code></pre> <p>This creates the following structure:</p> <pre><code>my_survey_project/\n    README.md\n    data_raw/          # Original source data (do not modify)\n    data_clean/        # Cleaned / processed data\n    outputs/           # Analysis results, tables, statistics\n    maps/              # Exported maps (PNG, HTML)\n    scripts/\n        process.py     # Starter processing script\n</code></pre>"},{"location":"getting-started/project-init/#folder-conventions","title":"Folder conventions","text":"Folder Purpose <code>data_raw/</code> Store original datasets here. Treat this as read-only to preserve data provenance. <code>data_clean/</code> Processed, cleaned, or reprojected data ready for analysis. <code>outputs/</code> Analysis results: CSVs, statistics, exported tables. <code>maps/</code> Generated map images (PNG) and interactive maps (HTML). <code>scripts/</code> Python processing scripts. A starter <code>process.py</code> is included."},{"location":"getting-started/project-init/#the-starter-script","title":"The starter script","text":"<p>The generated <code>scripts/process.py</code> contains a minimal template:</p> <pre><code>\"\"\"Processing script -- edit this for your workflow.\"\"\"\n\nfrom sudapy.crs.registry import suggest_utm_zone\nfrom sudapy.vector.ops import reproject\n\n# Example: suggest CRS for Khartoum\nprint(suggest_utm_zone(lon=32.5, lat=15.6))\n</code></pre> <p>Edit this file to build your processing pipeline.</p>"},{"location":"getting-started/project-init/#typical-workflow","title":"Typical workflow","text":"<pre><code># 1. Create project\nsudapy init khartoum_analysis\n\ncd khartoum_analysis\n\n# 2. Copy raw data\ncp ~/Downloads/parcels.gpkg data_raw/\n\n# 3. Process\nsudapy vector reproject --in data_raw/parcels.gpkg --out data_clean/parcels_utm.gpkg --to 32636\nsudapy vector area --in data_clean/parcels_utm.gpkg --field area_m2 --out data_clean/parcels_area.gpkg\n\n# 4. Generate report\nsudapy report --in data_clean/parcels_area.gpkg\n\n# 5. Export map\nsudapy map quick --in data_clean/parcels_area.gpkg --out maps/parcels.html\n</code></pre>"},{"location":"getting-started/quickstart/","title":"Quickstart","text":"<p>This guide walks through the most common SudaPy workflows in five minutes.</p>"},{"location":"getting-started/quickstart/#1-check-your-environment","title":"1. Check your environment","text":"<pre><code>sudapy doctor\n</code></pre> <p>If any checks fail, see the Installation page for troubleshooting.</p>"},{"location":"getting-started/quickstart/#2-list-available-crs-presets","title":"2. List available CRS presets","text":"<pre><code>sudapy crs list\n</code></pre> <p>Output:</p> EPSG Name Region 4326 WGS 84 Global 32634 WGS 84 / UTM zone 34N Western Sudan 32635 WGS 84 / UTM zone 35N Central Sudan 32636 WGS 84 / UTM zone 36N Eastern Sudan 32637 WGS 84 / UTM zone 37N Red Sea / Far-Eastern Sudan 20135 Adindan / UTM zone 35N Central Sudan (legacy) 20136 Adindan / UTM zone 36N Eastern Sudan (legacy) 20137 Adindan / UTM zone 37N Red Sea (legacy)"},{"location":"getting-started/quickstart/#3-suggest-the-right-crs-for-a-coordinate","title":"3. Suggest the right CRS for a coordinate","text":"<pre><code>sudapy crs suggest --lon 32.5 --lat 15.6\n</code></pre> <p>This returns the WGS 84 UTM zone plus any matching Adindan legacy zone.</p>"},{"location":"getting-started/quickstart/#4-reproject-a-vector-file","title":"4. Reproject a vector file","text":"<pre><code>sudapy vector reproject --in data/regions.gpkg --out data/regions_utm.gpkg --to 32636\n</code></pre>"},{"location":"getting-started/quickstart/#5-calculate-area-in-square-meters","title":"5. Calculate area in square meters","text":"<pre><code>sudapy vector area --in data/parcels.gpkg --field area_m2 --out data/parcels_area.gpkg\n</code></pre> <p>Note</p> <p>If the input CRS is geographic (lat/lon), SudaPy auto-projects to the estimated UTM zone for accurate metric area.</p>"},{"location":"getting-started/quickstart/#6-create-a-quick-map","title":"6. Create a quick map","text":"Static PNGInteractive HTML <pre><code>sudapy map quick --in data/regions.gpkg --out map.png\n</code></pre> <pre><code>sudapy map quick --in data/regions.gpkg --out map.html\n</code></pre>"},{"location":"getting-started/quickstart/#7-python-api","title":"7. Python API","text":"<pre><code>from sudapy.crs.registry import suggest_utm_zone\nfrom sudapy.vector.ops import reproject, calculate_area, buffer\n\n# Find the right zone\nsuggestions = suggest_utm_zone(lon=32.5, lat=15.6)\nprint(suggestions[0][\"epsg\"])  # 32636\n\n# Reproject\ngdf = reproject(\"input.gpkg\", to_epsg=32636, out=\"output.gpkg\")\n\n# Calculate area\ngdf = calculate_area(\"parcels.gpkg\", field=\"area_m2\", out=\"parcels_area.gpkg\")\n\n# Buffer by 500 meters (auto-projects if geographic CRS)\ngdf = buffer(\"points.gpkg\", distance_m=500, out=\"buffered.gpkg\")\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next steps","text":"<ul> <li>CRS &amp; Coordinate Systems Guide -- deep dive into Sudan CRS</li> <li>Vector Operations Guide -- all vector geoprocessing</li> <li>Raster Operations Guide -- raster processing workflows</li> <li>CLI Reference -- complete command-line reference</li> </ul>"},{"location":"guide/batch/","title":"Batch Processing","text":"<p>The <code>sudapy batch</code> command applies a single operation to all vector files in a directory.</p>"},{"location":"guide/batch/#supported-operations","title":"Supported operations","text":"Operation Required options Description <code>reproject</code> <code>--to EPSG</code> Reproject all files <code>clip</code> <code>--clip FILE</code> Clip all files by a geometry <code>buffer</code> <code>--distance METERS</code> Buffer all geometries <code>area</code> <code>--field NAME</code> (optional) Add area column <code>simplify</code> <code>--tolerance METERS</code> Simplify geometries <code>fix-geometry</code> (none) Repair invalid geometries"},{"location":"guide/batch/#usage","title":"Usage","text":"<pre><code>sudapy batch OPERATION --in INPUT_DIR --out OUTPUT_DIR [OPTIONS]\n</code></pre>"},{"location":"guide/batch/#examples","title":"Examples","text":""},{"location":"guide/batch/#reproject-all-files-to-utm-zone-36n","title":"Reproject all files to UTM zone 36N","text":"<pre><code>sudapy batch reproject --in data_raw/ --out data_clean/ --to 32636\n</code></pre>"},{"location":"guide/batch/#buffer-all-files-by-500-meters","title":"Buffer all files by 500 meters","text":"<pre><code>sudapy batch buffer --in data_clean/ --out buffered/ --distance 500\n</code></pre>"},{"location":"guide/batch/#calculate-area-for-all-files","title":"Calculate area for all files","text":"<pre><code>sudapy batch area --in data_clean/ --out with_area/ --field area_m2\n</code></pre>"},{"location":"guide/batch/#fix-geometries-in-all-files","title":"Fix geometries in all files","text":"<pre><code>sudapy batch fix-geometry --in problematic/ --out fixed/\n</code></pre>"},{"location":"guide/batch/#clip-all-files-by-a-boundary","title":"Clip all files by a boundary","text":"<pre><code>sudapy batch clip --in state_data/ --out clipped/ --clip national_boundary.gpkg\n</code></pre>"},{"location":"guide/batch/#how-it-works","title":"How it works","text":"<ol> <li>Scans the input directory for files with extensions <code>.gpkg</code>, <code>.geojson</code>, <code>.json</code>, or <code>.shp</code></li> <li>Applies the operation to each file</li> <li>Writes results to the output directory with the same filename</li> <li>Reports success/failure for each file</li> </ol> <p>Output example:</p> <pre><code>Processing 5 files with operation 'reproject' ...\n  OK parcels.gpkg\n  OK roads.gpkg\n  OK buildings.gpkg\n  FAIL boundaries.gpkg: Input dataset has no CRS.\n  OK rivers.gpkg\n\n4/5 files processed -&gt; data_clean/\n</code></pre>"},{"location":"guide/batch/#python-equivalent","title":"Python equivalent","text":"<p>For more control, use a Python script:</p> <pre><code>from pathlib import Path\nfrom sudapy.vector.ops import reproject\n\ninput_dir = Path(\"data_raw\")\noutput_dir = Path(\"data_clean\")\noutput_dir.mkdir(exist_ok=True)\n\nfor f in input_dir.glob(\"*.gpkg\"):\n    try:\n        reproject(f, to_epsg=32636, out=output_dir / f.name)\n        print(f\"OK {f.name}\")\n    except Exception as e:\n        print(f\"FAIL {f.name}: {e}\")\n</code></pre>"},{"location":"guide/crs/","title":"CRS &amp; Coordinate Systems","text":"<p>SudaPy includes built-in CRS presets tailored for Sudan and a suggestion engine that recommends the correct UTM zone for any coordinate.</p>"},{"location":"guide/crs/#why-crs-matters-in-sudan","title":"Why CRS matters in Sudan","text":"<p>Sudan spans UTM zones 34 through 37 North, covering longitudes from roughly 22 E to 38 E. Choosing the wrong UTM zone leads to significant distortion in area and distance calculations.</p> <p>Additionally, legacy survey data in Sudan often uses the Adindan datum rather than WGS 84. SudaPy includes both WGS 84 and Adindan presets.</p>"},{"location":"guide/crs/#built-in-presets","title":"Built-in presets","text":"EPSG Name Region 4326 WGS 84 Global (geographic, lat/lon) 32634 WGS 84 / UTM zone 34N Western Sudan (~18--24 E) 32635 WGS 84 / UTM zone 35N Central Sudan (~24--30 E) 32636 WGS 84 / UTM zone 36N Eastern Sudan (~30--36 E) 32637 WGS 84 / UTM zone 37N Red Sea coast (~36--42 E) 20135 Adindan / UTM zone 35N Central Sudan (legacy surveys) 20136 Adindan / UTM zone 36N Eastern Sudan (legacy surveys) 20137 Adindan / UTM zone 37N Red Sea (legacy surveys)"},{"location":"guide/crs/#suggest-the-right-crs","title":"Suggest the right CRS","text":""},{"location":"guide/crs/#cli","title":"CLI","text":"<pre><code># Khartoum (lon 32.5, lat 15.6)\nsudapy crs suggest --lon 32.5 --lat 15.6\n</code></pre> <p>Returns both WGS 84 / UTM zone 36N (EPSG:32636) and Adindan / UTM zone 36N (EPSG:20136).</p> <pre><code># Port Sudan on the Red Sea coast\nsudapy crs suggest --lon 37.2 --lat 19.6\n</code></pre> <p>Returns WGS 84 / UTM zone 37N (EPSG:32637) and Adindan / UTM zone 37N (EPSG:20137).</p>"},{"location":"guide/crs/#python-api","title":"Python API","text":"<pre><code>from sudapy.crs.registry import suggest_utm_zone\n\nsuggestions = suggest_utm_zone(lon=32.5, lat=15.6)\nfor s in suggestions:\n    print(f\"EPSG:{s['epsg']}  {s['name']}  ({s['datum']})\")\n</code></pre> <p>Output:</p> <pre><code>EPSG:32636  WGS 84 / UTM zone 36N  (WGS 84)\nEPSG:20136  Adindan / UTM zone 36N  (Adindan)\n</code></pre>"},{"location":"guide/crs/#list-all-presets","title":"List all presets","text":""},{"location":"guide/crs/#cli_1","title":"CLI","text":"<pre><code>sudapy crs list\n</code></pre>"},{"location":"guide/crs/#python-api_1","title":"Python API","text":"<pre><code>from sudapy.crs.registry import list_presets\n\nfor preset in list_presets():\n    print(f\"EPSG:{preset.epsg}  {preset.name}  ({preset.region})\")\n</code></pre>"},{"location":"guide/crs/#validate-an-epsg-code","title":"Validate an EPSG code","text":"<pre><code>from sudapy.crs.registry import validate_epsg\n\ncrs = validate_epsg(32636)\nprint(crs)  # &lt;CRS: EPSG:32636&gt;\n</code></pre> <p>If the EPSG code is invalid, a <code>CRSError</code> is raised with a helpful hint.</p>"},{"location":"guide/crs/#adindan-vs-wgs-84","title":"Adindan vs WGS 84","text":"<p>When to use Adindan</p> <p>Use Adindan CRS only when working with legacy survey data that was originally collected in the Adindan datum. For new projects, WGS 84 UTM zones are recommended.</p> <p>The Adindan datum (also called Blue Nile 1958) was the standard geodetic datum used in Sudan for decades. A datum transformation is required when combining Adindan data with modern WGS 84 datasets:</p> <pre><code>from sudapy.vector.ops import reproject\n\n# Convert legacy Adindan data to WGS 84 / UTM zone 36N\ngdf = reproject(\"legacy_survey.gpkg\", to_epsg=32636, out=\"survey_wgs84.gpkg\")\n</code></pre> <p>Warning</p> <p>Datum transformations between Adindan and WGS 84 can introduce shifts of several hundred meters depending on the transformation parameters available. Always validate transformed coordinates against known control points.</p>"},{"location":"guide/raster/","title":"Raster Operations","text":"<p>SudaPy wraps <code>rasterio</code> to provide high-level raster processing. Supported input formats: GeoTIFF (<code>.tif</code>, <code>.tiff</code>), ERDAS Imagine (<code>.img</code>), and VRT (<code>.vrt</code>).</p>"},{"location":"guide/raster/#clip-by-vector","title":"Clip by vector","text":"<p>Clip a raster using vector geometries as a mask.</p> CLIPython <pre><code>sudapy raster clip --in dem.tif --clip boundary.gpkg --out dem_clipped.tif\n</code></pre> <pre><code>from sudapy.raster.ops import clip\n\nclip(\"dem.tif\", \"boundary.gpkg\", out=\"dem_clipped.tif\")\n</code></pre> <p>The clip vector is automatically reprojected to match the raster CRS if needed.</p>"},{"location":"guide/raster/#reproject","title":"Reproject","text":"<p>Reproject a raster to a new coordinate reference system.</p> CLIPython <pre><code>sudapy raster reproject --in image.tif --out image_utm.tif --to 32636\n</code></pre> <pre><code>from sudapy.raster.ops import reproject_raster\n\nreproject_raster(\"image.tif\", \"image_utm.tif\", to_epsg=32636)\n</code></pre>"},{"location":"guide/raster/#resample","title":"Resample","text":"<p>Change raster resolution by a scale factor.</p> CLIPython <pre><code># Double the resolution\nsudapy raster resample --in image.tif --out image_hires.tif --scale 2.0\n\n# Use cubic resampling\nsudapy raster resample --in image.tif --out image_hires.tif --scale 2.0 --method cubic\n</code></pre> <pre><code>from sudapy.raster.ops import resample\n\nresample(\"image.tif\", \"image_hires.tif\", scale_factor=2.0, method=\"bilinear\")\n</code></pre> <p>Available resampling methods:</p> Method Description <code>nearest</code> Nearest neighbor (fast, good for categorical data) <code>bilinear</code> Bilinear interpolation (good default for continuous data) <code>cubic</code> Cubic convolution (smooth, best for visual quality)"},{"location":"guide/raster/#mosaic","title":"Mosaic","text":"<p>Merge multiple raster tiles from a directory into a single raster.</p> CLIPython <pre><code>sudapy raster mosaic --in tiles/ --out merged.tif\n</code></pre> <pre><code>from sudapy.raster.ops import mosaic\n\nmosaic(\"tiles/\", \"merged.tif\")\n</code></pre> <p>All <code>.tif</code>, <code>.tiff</code>, <code>.img</code>, and <code>.vrt</code> files in the directory are included.</p>"},{"location":"guide/raster/#hillshade","title":"Hillshade","text":"<p>Generate a hillshade visualization from a Digital Elevation Model (DEM).</p> CLIPython <pre><code>sudapy raster hillshade --in dem.tif --out hillshade.tif\n\n# Custom sun position\nsudapy raster hillshade --in dem.tif --out hillshade.tif --azimuth 270 --altitude 30\n</code></pre> <pre><code>from sudapy.raster.ops import hillshade\n\nhillshade(\"dem.tif\", \"hillshade.tif\", azimuth=315.0, altitude=45.0)\n</code></pre> <p>Parameters:</p> Parameter Default Description <code>azimuth</code> 315.0 Sun direction in degrees (315 = northwest) <code>altitude</code> 45.0 Sun angle above horizon in degrees"},{"location":"guide/raster/#slope","title":"Slope","text":"<p>Calculate slope in degrees from a DEM.</p> CLIPython <pre><code>sudapy raster slope --in dem.tif --out slope.tif\n</code></pre> <pre><code>from sudapy.raster.ops import slope\n\nslope(\"dem.tif\", \"slope.tif\")\n</code></pre> <p>The output raster contains slope values in degrees (0 = flat, 90 = vertical).</p>"},{"location":"guide/raster/#terrain-analysis-workflow","title":"Terrain analysis workflow","text":"<p>A common DEM analysis workflow:</p> <pre><code># 1. Clip DEM to study area\nsudapy raster clip --in srtm_36n.tif --clip study_area.gpkg --out dem.tif\n\n# 2. Reproject to UTM for accurate measurements\nsudapy raster reproject --in dem.tif --out dem_utm.tif --to 32636\n\n# 3. Generate terrain products\nsudapy raster hillshade --in dem_utm.tif --out hillshade.tif\nsudapy raster slope --in dem_utm.tif --out slope.tif\n</code></pre>"},{"location":"guide/remote-sensing/","title":"Remote Sensing","text":"<p>SudaPy includes helpers for searching and downloading Sentinel satellite imagery via the Copernicus Open Access Hub.</p> <p>Optional dependency</p> <p>Remote sensing features require the <code>rs</code> extra: <code>pip install \"sudapy[rs]\"</code></p>"},{"location":"guide/remote-sensing/#setup","title":"Setup","text":""},{"location":"guide/remote-sensing/#1-install-the-extra","title":"1. Install the extra","text":"<pre><code>pip install \"sudapy[rs]\"\n</code></pre>"},{"location":"guide/remote-sensing/#2-set-copernicus-credentials","title":"2. Set Copernicus credentials","text":"<p>Register at Copernicus Open Access Hub, then set environment variables:</p> Linux / macOSWindows (cmd)Windows (PowerShell) <pre><code>export COPERNICUS_USER=your_username\nexport COPERNICUS_PASSWORD=your_password\n</code></pre> <pre><code>set COPERNICUS_USER=your_username\nset COPERNICUS_PASSWORD=your_password\n</code></pre> <pre><code>$env:COPERNICUS_USER = \"your_username\"\n$env:COPERNICUS_PASSWORD = \"your_password\"\n</code></pre>"},{"location":"guide/remote-sensing/#search-for-scenes","title":"Search for scenes","text":""},{"location":"guide/remote-sensing/#cli","title":"CLI","text":"<pre><code>sudapy rs sentinel-search \\\n    --lon 32.5 --lat 15.6 \\\n    --start 2025-01-01 --end 2025-06-30 \\\n    --platform Sentinel-2 \\\n    --max-cloud 20\n</code></pre>"},{"location":"guide/remote-sensing/#python","title":"Python","text":"<pre><code>from sudapy.rs.sentinel import search_scenes\n\nresults = search_scenes(\n    lon=32.5,\n    lat=15.6,\n    start_date=\"2025-01-01\",\n    end_date=\"2025-06-30\",\n    platform_name=\"Sentinel-2\",\n    max_cloud=20,\n)\n\nfor scene in results[:5]:\n    print(f\"{scene['date']}  cloud={scene['cloud_cover']:.1f}%  {scene['title']}\")\n</code></pre>"},{"location":"guide/remote-sensing/#search-parameters","title":"Search parameters","text":"Parameter Default Description <code>lon</code>, <code>lat</code> (required) Center point coordinates <code>start_date</code>, <code>end_date</code> (required) Date range as YYYY-MM-DD <code>platform_name</code> <code>Sentinel-2</code> Satellite platform <code>max_cloud</code> <code>30</code> Maximum cloud cover percentage"},{"location":"guide/remote-sensing/#return-format","title":"Return format","text":"<p>Each result is a dictionary:</p> <pre><code>{\n    \"uuid\": \"abc123...\",\n    \"title\": \"S2A_MSIL1C_20250115T...\",\n    \"date\": \"2025-01-15\",\n    \"cloud_cover\": 12.3,\n}\n</code></pre>"},{"location":"guide/remote-sensing/#download-a-scene","title":"Download a scene","text":""},{"location":"guide/remote-sensing/#cli_1","title":"CLI","text":"<pre><code>sudapy rs sentinel-download --uuid abc123... --out downloads/\n</code></pre>"},{"location":"guide/remote-sensing/#python_1","title":"Python","text":"<pre><code>from sudapy.rs.sentinel import download_scene\n\npath = download_scene(uuid=\"abc123...\", out_dir=\"downloads/\")\nprint(f\"Downloaded to: {path}\")\n</code></pre>"},{"location":"guide/remote-sensing/#workflow-example","title":"Workflow example","text":"<pre><code># 1. Search for recent low-cloud Sentinel-2 scenes near Khartoum\nsudapy rs sentinel-search \\\n    --lon 32.5 --lat 15.6 \\\n    --start 2025-01-01 --end 2025-03-31 \\\n    --max-cloud 10\n\n# 2. Download a specific scene (copy UUID from search results)\nsudapy rs sentinel-download --uuid &lt;UUID&gt; --out data_raw/\n\n# 3. Process the downloaded raster\nsudapy raster clip --in data_raw/scene.tif --clip study_area.gpkg --out clipped.tif\nsudapy raster reproject --in clipped.tif --out scene_utm.tif --to 32636\n</code></pre>"},{"location":"guide/vector/","title":"Vector Operations","text":"<p>SudaPy provides a set of vector geoprocessing functions accessible from both the CLI and Python API. All functions accept GeoPackage (<code>.gpkg</code>), GeoJSON, and Shapefile (<code>.shp</code>) formats.</p>"},{"location":"guide/vector/#reproject","title":"Reproject","text":"<p>Change the coordinate reference system of a vector dataset.</p> CLIPython <pre><code>sudapy vector reproject --in regions.gpkg --out regions_utm.gpkg --to 32636\n</code></pre> <pre><code>from sudapy.vector.ops import reproject\n\ngdf = reproject(\"regions.gpkg\", to_epsg=32636, out=\"regions_utm.gpkg\")\n</code></pre>"},{"location":"guide/vector/#clip","title":"Clip","text":"<p>Clip a vector dataset using another geometry as a mask.</p> CLIPython <pre><code>sudapy vector clip --in parcels.gpkg --clip boundary.gpkg --out clipped.gpkg\n</code></pre> <pre><code>from sudapy.vector.ops import clip\n\ngdf = clip(\"parcels.gpkg\", \"boundary.gpkg\", out=\"clipped.gpkg\")\n</code></pre> <p>Note</p> <p>If the clip geometry has a different CRS, SudaPy automatically reprojects it to match the input.</p>"},{"location":"guide/vector/#dissolve","title":"Dissolve","text":"<p>Merge geometries by an attribute field.</p> CLIPython <pre><code>sudapy vector dissolve --in districts.gpkg --by state_name --out states.gpkg\n</code></pre> <pre><code>from sudapy.vector.ops import dissolve\n\ngdf = dissolve(\"districts.gpkg\", by=\"state_name\", out=\"states.gpkg\")\n</code></pre>"},{"location":"guide/vector/#calculate-area","title":"Calculate area","text":"<p>Add an area column in square meters.</p> CLIPython <pre><code>sudapy vector area --in parcels.gpkg --field area_m2 --out parcels_area.gpkg\n</code></pre> <pre><code>from sudapy.vector.ops import calculate_area\n\ngdf = calculate_area(\"parcels.gpkg\", field=\"area_m2\", out=\"parcels_area.gpkg\")\n</code></pre> <p>Automatic UTM projection</p> <p>If the input CRS is geographic (lat/lon), SudaPy temporarily projects to the estimated UTM zone for accurate metric area. A warning is emitted. For best accuracy, reproject your data to a projected CRS first.</p>"},{"location":"guide/vector/#buffer","title":"Buffer","text":"<p>Create buffer zones around geometries. Distance is specified in meters.</p> CLIPython <pre><code>sudapy vector buffer --in wells.gpkg --distance 500 --out wells_buffer.gpkg\n</code></pre> <pre><code>from sudapy.vector.ops import buffer\n\ngdf = buffer(\"wells.gpkg\", distance_m=500, out=\"wells_buffer.gpkg\")\n</code></pre> <p>If the input CRS is geographic, SudaPy auto-projects to UTM, applies the buffer in meters, then projects back to the original CRS.</p>"},{"location":"guide/vector/#simplify","title":"Simplify","text":"<p>Reduce vertex count using the Douglas-Peucker algorithm. Tolerance is in meters.</p> CLIPython <pre><code>sudapy vector simplify --in detailed.gpkg --tolerance 100 --out simplified.gpkg\n</code></pre> <pre><code>from sudapy.vector.ops import simplify\n\ngdf = simplify(\"detailed.gpkg\", tolerance_m=100, out=\"simplified.gpkg\")\n</code></pre>"},{"location":"guide/vector/#fix-geometry","title":"Fix geometry","text":"<p>Repair invalid geometries using Shapely's <code>make_valid</code>.</p> CLIPython <pre><code>sudapy vector fix-geometry --in broken.gpkg --out fixed.gpkg\n</code></pre> <pre><code>from sudapy.vector.ops import fix_geometry\n\ngdf = fix_geometry(\"broken.gpkg\", out=\"fixed.gpkg\")\n</code></pre> <p>Tip</p> <p>Run <code>sudapy report --in file.gpkg</code> first to check how many invalid geometries exist before fixing.</p>"},{"location":"guide/vector/#supported-formats","title":"Supported formats","text":"Extension Format Read Write <code>.gpkg</code> GeoPackage Yes Yes <code>.geojson</code> / <code>.json</code> GeoJSON Yes Yes <code>.shp</code> ESRI Shapefile Yes Yes"},{"location":"guide/vector/#working-with-geodataframes-directly","title":"Working with GeoDataFrames directly","text":"<p>All functions accept either a file path or a <code>geopandas.GeoDataFrame</code>. The <code>out</code> parameter is optional -- omit it to get the result in memory without writing to disk:</p> <pre><code>import geopandas as gpd\nfrom sudapy.vector.ops import buffer, calculate_area\n\ngdf = gpd.read_file(\"parcels.gpkg\")\n\n# Chain operations in memory\ngdf = calculate_area(gdf, field=\"area_m2\")\ngdf = buffer(gdf, distance_m=100)\n\n# Write only at the end\ngdf.to_file(\"result.gpkg\", driver=\"GPKG\")\n</code></pre>"},{"location":"guide/visualization/","title":"Visualization","text":"<p>SudaPy provides a <code>quick_map</code> function for fast visualization of vector and raster data. Output formats include static PNG images and interactive HTML maps.</p> <p>Optional dependency</p> <p>Visualization requires the <code>viz</code> extra: <code>pip install \"sudapy[viz]\"</code></p>"},{"location":"guide/visualization/#quick-map-export","title":"Quick map export","text":""},{"location":"guide/visualization/#static-png","title":"Static PNG","text":"CLIPython <pre><code>sudapy map quick --in regions.gpkg --out map.png\n</code></pre> <pre><code>from sudapy.viz.maps import quick_map\n\nquick_map(\"regions.gpkg\", \"map.png\")\n</code></pre> <p>Generates a 150 DPI image using matplotlib.</p>"},{"location":"guide/visualization/#interactive-html","title":"Interactive HTML","text":"CLIPython <pre><code>sudapy map quick --in regions.gpkg --out map.html\n</code></pre> <pre><code>from sudapy.viz.maps import quick_map\n\nquick_map(\"regions.gpkg\", \"map.html\", title=\"Sudan Regions\")\n</code></pre> <p>Generates a Leaflet map using folium with OpenStreetMap basemap and layer controls.</p>"},{"location":"guide/visualization/#supported-input-types","title":"Supported input types","text":"Input type PNG output HTML output Vector (<code>.gpkg</code>, <code>.shp</code>, <code>.geojson</code>) Matplotlib plot Folium GeoJSON overlay Raster (<code>.tif</code>, <code>.tiff</code>, <code>.img</code>) rasterio plot Bounds rectangle on map"},{"location":"guide/visualization/#output-format-selection","title":"Output format selection","text":"<p>The output format is determined by the file extension:</p> <ul> <li><code>.png</code>, <code>.jpg</code> -- static image via matplotlib</li> <li><code>.html</code> -- interactive Leaflet map via folium</li> </ul>"},{"location":"guide/visualization/#combining-with-other-operations","title":"Combining with other operations","text":"<p>A common workflow is to process data then visualize:</p> <pre><code>from sudapy.vector.ops import clip, calculate_area\nfrom sudapy.viz.maps import quick_map\n\n# Process\ngdf = clip(\"parcels.gpkg\", \"city_boundary.gpkg\", out=\"city_parcels.gpkg\")\ngdf = calculate_area(gdf, field=\"area_m2\", out=\"city_parcels_area.gpkg\")\n\n# Visualize\nquick_map(\"city_parcels_area.gpkg\", \"city_parcels.html\", title=\"City Parcels\")\nquick_map(\"city_parcels_area.gpkg\", \"city_parcels.png\")\n</code></pre>"}]}